---
title: "Claude Code カスタムスラッシュコマンド実装ガイド ─ 繰り返し作業を1コマンドで自動化"
emoji: "⚡"
type: "tech"
topics: ["claudecode", "claude", "ai", "自動化", "開発効率化"]
published: false
publication_name: "correlate_dev"
---

## はじめに

Claude Codeを使い始めると、毎回同じような作業を手で指示していることに気づきます。

- 「セッション開始時に前回の続きを確認して、今日のタスクを整理してください」
- 「このコードをセキュリティ・データ整合性・エラーハンドリングの観点でレビューしてください」
- 「このトピックで競合記事を調査して、差別化ポイントを整理してください」

こうした定型的な指示を毎回入力するのは非効率です。Claude Codeには**カスタムスラッシュコマンド（Skills）**という仕組みがあり、これを使うと `/session-start` や `/da-review` のように1コマンドで複雑な作業を起動できます。

この記事では、実際に運用しているスキルファイルをそのまま紹介しながら、カスタムスラッシュコマンドの作り方と活用パターンを解説します。

---

## スラッシュコマンド（Skills）の仕組み

### `~/.claude/skills/` ディレクトリ

Claude Codeのカスタムスラッシュコマンドは、ホームディレクトリの `~/.claude/skills/` 以下にマークダウンファイルを置くことで定義します。

```
~/.claude/skills/
├── session-start/
│   └── SKILL.md       ← /session-start コマンドの定義
├── da-review/
│   └── SKILL.md       ← /da-review コマンドの定義
├── content-research/
│   └── SKILL.md       ← /content-research コマンドの定義
└── （任意のスキル名）/
    └── SKILL.md
```

ルールはシンプルです。

- ディレクトリ名 = スラッシュコマンド名
- ディレクトリ内に `SKILL.md` を置く
- Claude Code内で `/スキル名` と入力すると呼び出せる

### 実行フロー

```mermaid
graph TD
    A[ユーザーが /スキル名 を入力] --> B{スキルファイルを検索}
    B --> C[~/.claude/skills/{スキル名}/SKILL.md を読み込み]
    C --> D[フロントマターでツール権限を確認]
    D --> E[本文プロンプトに $ARGUMENTS を展開]
    E --> F[Claudeが指示に従い作業を実行]
    F --> G[成果物を指定パスに保存]
```

---

## スキルファイルの基本構造

スキルファイルは**フロントマター + プロンプト本文**で構成されます。

```markdown
---
name: スキル名
description: >
  スキルの説明（Claudeがスキル選択時に参照する）
user-invocable: true
version: 1.0.0
tools: Read, Write, Edit, Bash, Glob, Grep, WebSearch, WebFetch
---

ここにプロンプト本文を書く。
対象: $ARGUMENTS（呼び出し時の引数が展開される）

## 手順
1. ...
2. ...
```

### フロントマターの各フィールド

| フィールド | 説明 | 例 |
|-----------|------|-----|
| `name` | スキル名（コマンド名と対応） | `session-start` |
| `description` | スキルの説明 | `セッション開始ルーチンを実行します` |
| `user-invocable` | ユーザーが直接呼び出せるか | `true` |
| `version` | バージョン管理用 | `1.0.0` |
| `tools` | 使用するツールのリスト | `Read, Write, Bash` |
| `disable-model-invocation` | モデル推論なしで実行するか | `true`（省略可） |

`tools` フィールドは**セキュリティ上重要**です。スキルが必要とするツールだけを列挙することで、意図しないツール使用を防ぎます。たとえばレビュー系スキルなら `Bash` を外し、ファイルの読み書きだけ許可するといった使い分けができます。

### `$ARGUMENTS` で引数を受け取る

スキル呼び出し時に渡された文字列は `$ARGUMENTS` に展開されます。

```
/da-review src/api/client.ts
```

このとき、スキルファイル内の `$ARGUMENTS` が `src/api/client.ts` に置き換わります。引数がない場合は空文字になるため、「指定がなければ直近の成果物を推定」のようなフォールバック処理をプロンプトに記述しておくとよいです。

---

## 実例1: `/session-start`（セッション開始ルーチン）

### ユースケース

毎日の作業開始時に行う定型処理を自動化します。前回セッションの引き継ぎ確認、今日のDaily Note作成、ニューススキャン実行など、10ステップ近い手順を1コマンドで処理します。

### スキルファイル（`~/.claude/skills/session-start/SKILL.md`）

```markdown
---
name: session-start
description: >
  セッション開始ルーチンを実行します。current-state.md読み込み、セッション記録作成、
  ニューススキャン自動実行、ワークスペース鮮度チェックを含みます。
user-invocable: true
disable-model-invocation: true
version: 1.0.0
tools: Read, Write, Edit, Bash, Glob, Grep, WebSearch, WebFetch
---

セッション開始ルーチンを実行してください:

1. **current-state.md を最優先で読む**（前セッションからの自動引き継ぎ）:
   ```bash
   cat ~/dev/Obsidian/06_sessions/current-state.md 2>/dev/null
   ```
   - 前セッション終了時に自動生成されるファイル
   - Handoff（完了状態、残タスク、次にやること）が記載済み
   - 存在しない場合は手順2へフォールバック

2. 直近3つのセッション記録を確認:
   ```bash
   ls -t ~/dev/Obsidian/06_sessions/$(date +%Y)/$(date +%m)/*.md | head -3
   ```
   最新ファイルを読み、Handoff/Next Stepsセクションを確認

3. 今日のDaily Noteを確認/作成

4. 新しいセッション記録ファイルを作成

5. **ニューススキャン**（毎セッション自動実行）:
   今日のダイジェストがない場合 → `/news-scan` を自動実行

6. タスク宣言をユーザーに確認

前回セッションのNext Stepsに基づいて、今回やるべきことを提案してください。
```

### ポイント

- `disable-model-invocation: true` を指定しているため、スキル起動時にモデルが余計な推論をせず、プロンプトに従った手順を確実に実行します
- `current-state.md` という引き継ぎファイルを軸に設計することで、セッションをまたいだ作業継続がスムーズになります

---

## 実例2: `/da-review`（デビルズアドボケイトレビュー）

### ユースケース

コードや記事を批判的な視点でレビューします。「うまくいかない可能性は何か」「セキュリティの穴はないか」を体系的にチェックし、HIGH/MEDIUM/LOWで重要度分類した結果を出力します。

### スキルファイル（`~/.claude/skills/da-review/SKILL.md`）

```markdown
---
name: da-review
description: >
  デビルズアドボケイト（批判的レビュー）を実施します。セキュリティ、データ整合性、
  エラーハンドリング、FIRE基準の観点で成果物を評価し、HIGH/MEDIUM/LOWで分類します。
user-invocable: true
version: 1.0.0
tools: Read, Write, Edit, Bash, Glob, Grep
---

デビルズアドボケイト（批判的レビュー）を実施してください。

対象: $ARGUMENTS（指定がなければ直近の成果物を推定）

## レビュー観点

### 必須チェック（全成果物共通）
- [ ] セキュリティ: APIキー露出、SQLインジェクション、XSS、認証の穴
- [ ] データ整合性: 冪等性、重複、NULL処理、型の不一致
- [ ] エラーハンドリング: silent except、未処理例外、ログ不足

### コード品質（コード変更時）
- [ ] 命名の一貫性
- [ ] 不要な依存追加
- [ ] パフォーマンス懸念

### コンテンツ品質（記事レビュー時）
- [ ] 文体の統一
- [ ] 事実確認: 数値・URL・バージョン番号の正確性
- [ ] 構成: 導入→本題→まとめの流れ

## 出力フォーマット

各指摘を重要度（HIGH/MEDIUM/LOW）で分類:

```
[HIGH] カテゴリ: 指摘内容
  現状: ...
  推奨: ...
  理由: ...
```

最後にB+/A-等のグレード評価と、HIGHの件数サマリーを付けてください。
レビュー結果を ~/dev/Obsidian/03_knowledge/patterns/da-review-YYYY-MM-DD-{slug}.md に保存してください。
```

### 実行例

```
/da-review articles/new-article.md
```

出力例:

```
[HIGH] コンテンツ品質: バージョン番号が古い
  現状: 記事内で Claude 3.5 と記載
  推奨: 最新バージョンに更新するか「執筆時点のバージョン」と明記
  理由: 誤情報として読者に伝わるリスクがある

[MEDIUM] 構成: 導入部が長すぎる
  現状: 導入セクションが全体の30%を占めている
  推奨: 要点を絞り、本題への導入を短縮する

グレード: B+
HIGH: 1件 / MEDIUM: 1件 / LOW: 2件
```

### ポイント

- `tools` から `WebSearch` を除外しているのは、レビュー作業にWeb検索は不要なため
- `$ARGUMENTS` を「指定がなければ直近の成果物を推定」と書くことで、引数省略時も使いやすくなります

---

## 実例3: `/content-research`（Deep Research実施）

### ユースケース

記事を書く前の競合調査・公式ドキュメント収集・構成案作成を5フェーズで実行します。「リサーチなしで執筆開始禁止」というルールのゲートとして機能します。

### スキルファイル（`~/.claude/skills/content-research/SKILL.md`）

```markdown
---
name: content-research
description: >
  コンテンツDeep Researchを実施します。競合調査、公式ドキュメント収集、
  キーワード分析、構成案作成を含む5フェーズのリサーチプロセスです。
user-invocable: true
disable-model-invocation: true
version: 1.0.0
tools: Read, Write, Edit, Glob, Grep, WebSearch, WebFetch
---

コンテンツDeep Researchを実施してください。

対象: $ARGUMENTS（記事スラッグまたはトピック）

## リサーチ手順

### Phase 1: 競合調査
1. Zenn/Note/Qiitaで類似記事を検索（WebSearch使用）
2. 上位5記事のタイトル、いいね数、切り口を記録
3. 既存記事と何が違うか（差別化ポイント）を特定

### Phase 2: 公式ドキュメント・参考資料
1. 関連する公式ドキュメントのURL収集
2. 最新バージョン・仕様の確認
3. 引用可能なソースをURLと要約で記録

### Phase 3: キーワード・SEO調査
1. メインキーワードと関連キーワードの洗い出し
2. 検索意図の分析（情報収集/比較検討/実装方法）

### Phase 4: 構成案
1. ターゲット読者の定義
2. 記事の目次案（H2/H3レベル）
3. 推定文字数と配信先判定

### Phase 5: 次のネタ発見
- リサーチ中に見つけた派生トピックを候補リストに追記

## 出力先
~/dev/Obsidian/07_content_pipeline/research/research-{slug}.md

このファイルが完成するまで記事執筆に進んではいけません。
```

### ポイント

- `Bash` を `tools` から除外しているため、シェルコマンドの実行はできません。WebSearchとWebFetchによる調査に特化した設計です
- 「このファイルが完成するまで記事執筆に進んではいけません」という制約をプロンプト内に書くことで、ワークフローのゲート（関所）として機能します

---

## スキルの呼び出し方とTips

### 基本的な呼び出し方

```
# 引数なし
/session-start

# ファイルパスを渡す
/da-review src/components/Button.tsx

# スラッグを渡す
/content-research claude-code-slash-commands

# 複数トピックを渡す
/news-scan T1 T2 T4
```

### ツール権限の設計指針

スキルに必要最小限のツールだけを付与することを推奨します。

| スキル種別 | 推奨ツール | 除外するツール |
|-----------|-----------|--------------|
| レビュー系 | Read, Write, Glob, Grep | Bash, WebSearch |
| リサーチ系 | Read, Write, WebSearch, WebFetch | Bash |
| セッション管理 | Read, Write, Edit, Bash, Glob, Grep | WebSearch（不要な場合） |
| 自動化・実行系 | 全ツール | なし |

### デバッグ方法

スキルが期待通りに動作しない場合のチェックリストです。

1. **フロントマターの構文確認**: YAMLの字下げや `>` の使い方を確認
2. **ディレクトリ名とファイル名の確認**: `~/.claude/skills/{name}/SKILL.md` の形式になっているか
3. **`tools` の確認**: 必要なツールが全て列挙されているか（`Write` を忘れるとファイル保存ができない）
4. **`$ARGUMENTS` の展開確認**: 引数を渡して実行し、正しく展開されるか確認
5. **プロンプトの具体性**: 「〜してください」だけでなく、具体的な手順・出力パスを明記する

### スキルファイルを育てる

運用していると「このステップは不要だった」「このチェック項目を追加したい」という気づきが出てきます。スキルファイルは通常のテキストファイルなので、そのまま編集して更新できます。バージョン管理するなら `version` フィールドをインクリメントしておくと変更履歴が追いやすくなります。

---

## まとめ

Claude Codeのカスタムスラッシュコマンド（Skills）は、以下の3ステップで作れます。

1. `~/.claude/skills/{コマンド名}/SKILL.md` を作成する
2. フロントマターでツール権限を定義する
3. 本文にやってほしい作業をプロンプトで書く

実際に運用してみて感じるメリットは、**「何度も使うプロンプトを資産化できる」**という点です。スキルファイルはテキストなのでGitで管理でき、複数のマシンに同期することも容易です。

カスタマイズのポイントをまとめます。

- **`tools` は最小権限で**: 不要なツールを除外するとミスが減る
- **ゲートをプロンプトに書く**: 「〜が完了するまで次へ進まない」と明記するとワークフローの整合性が保てる
- **`$ARGUMENTS` で汎用化**: ハードコードを避け、引数で柔軟に対応できる設計にする
- **段階的に育てる**: 完璧なスキルファイルをいきなり書こうとせず、使いながら改善する

繰り返し作業をスキルファイルに落とし込んでいくと、Claude Codeが単なるチャットツールではなく、自分専用のAIアシスタントとして機能するようになります。ぜひ自分の作業フローに合ったスキルを作ってみてください。
